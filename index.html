<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Sunbeam metagenomics pipeline</title>
    <meta name="description" content="Sunbeam metagenomics analysis pipeline">
    <link rel="stylesheet" href="main.css">
    <link rel="canonical" href="http://sunbeam-labs.github.io/">
  </head>
  <body>

    <header class="site-header" role="banner">
      <div class="wrapper">
        <a class="site-title" href="http://sunbeam-labs.github.io/">Sunbeam metagenomics pipeline</a>
      </div>
    </header>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">

<p>Sunbeam is a bioinformatics analysis pipeline that supports
reproducible analysis of shotgun metagenomics data sets. Its main
feature is easy-to-make extensions, which allow users to specify
additional functionality for the pipeline with only a few lines of
code.</p>

<h2>Extensions</h2>

    <div id="exts">
    </div>

    <script type="text/javascript" src="https://cdn.bootcss.com/rest.js/15.2.6/octokit-rest.js" ></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script>
    const sunbeam_targets = {
      FASTQC_SUMMARY: [
        "str(QC_FP/'reports'/'fastqc_quality.tsv')",
        ],
      DECONTAM_SUMMARY: [
        "str(QC_FP/'reports'/'preprocess_summary.tsv')",
        ],
      KRAKEN_SUMMARY: [
        "str(CLASSIFY_FP/'kraken'/'all_samples.tsv')",
        ],
      DECONTAM_FASTQ: [
        "str(QC_FP/'decontam'/'{sample}_{rp}.fastq.gz')",
        "str(QC_FP/'decontam'/'{sample}_1.fastq.gz')",
        "str(QC_FP/'decontam'/'{sample}_2.fastq.gz')",
        "str(QC_FP/'decontam'/'{sample}_R1.fastq.gz')",
        "str(QC_FP/'decontam'/'{sample}_R2.fastq.gz')"
        ],
      CONTIG_FASTA: [
        "str(ASSEMBLY_FP/'contigs'/'{sample}-contigs.fa')",
        ],
      PROTEIN_FASTA: [
        "str(ANNOTATION_FP/'genes'/'prodigal'/'{sample}_genes_prot.fa')",
        ]
    };

    const find_sunbeam_targets = function (rules_txt) {
      const targets = [];
      for (const key in sunbeam_targets) {
        const search_strs = sunbeam_targets[key];
        for (var i = 0; i < search_strs.length; i++) {
          search_str = search_strs[i];
          if (rules_txt.indexOf(search_str) !== -1) {
            targets.push(key);
            break;
          }
        }
      }
      return targets;
    };

    const is_rules_file = function (file_info) {
      return (
        file_info.name.match(/\.rules$/) &&
        (file_info.type === "file"));
    };

    // Takes the result of getContent, returns an array of targets in the file.
    const get_rules_targets = function (file_info) {
      const rules_txt = window.atob(file_info.content);
      console.log(rules_txt);
      return find_sunbeam_targets(rules_txt);
    };

    const repos = [
      {owner: "sunbeam-labs", repo: "sbx_report"},
      {owner: "sunbeam-labs", repo: "sbx_contigs"},
      {owner: "sunbeam-labs", repo: "sbx_metaphlan"},
      {owner: "sunbeam-labs", repo: "sbx_shortbred"},
      {owner: "sunbeam-labs", repo: "sbx_gene_clusters"},
      {owner: "sunbeam-labs", repo: "sbx_spades"},
      {owner: "sunbeam-labs", repo: "sbx_anvio"},
      {owner: "sunbeam-labs", repo: "sbx_krakenhll"},
      {owner: "sunbeam-labs", repo: "sbx_igv"},
      {owner: "sunbeam-labs", repo: "sbx_kaiju"},
      {owner: "louiejtaylor", repo: "sbx_rgi"}
    ];

    const github_url = function ({owner, repo}) {
      return "https://github.com/" + owner + "/" + repo;
    }

    $(function () {
      const octokit = new Octokit();

      const get_repo_files = function (repo_info) {
        repo_query = Object.assign({path: ""}, repo_info);
        return octokit.repos.getContent(repo_query);
      };

      const get_repo_file_contents = function (repo_info, file_info) {
        rules_query = Object.assign({path: file_info.path}, repo_info);
        return octokit.repos.getContent(rules_query);
      };

      const exts_list = $("#exts");
      repos.forEach(function (repo_info) {
        const repo_card = $("<div/>");
        repo_card.appendTo(exts_list);

        const repo_header = $("<h3/>");
        const repo_link = $("<a/>").attr("href", github_url(repo_info));
        repo_link.text(repo_info.repo);
        repo_link.appendTo(repo_header);
        repo_header.appendTo(repo_card);

        const inject_info = function ({data}) {
          const container = $("<ul/>");
          const desc = data.description || "&nbsp;";
          container.append(
            "<li>Description: " + desc + "</li>",
            "<li>Last update: " + data.updated_at + "</li>",
            "<li>Watchers: " + data.watchers_count + "</li>",
            "<li>Open issues: " + data.open_issues_count + "</li>"
          );
          container.appendTo(repo_card);
        };

        const inject_targets = function ({data}) {
          const rules_container = $("<div/>");

          const header = $("<em/>");
          header.text(data.path);
          rules_container.append(header);

          const rules_link = $("<a/>").attr("href", data.html_url);
          rules_link.text("Source");
          rules_container.append(" [", rules_link, "]");

          const targets = get_rules_targets(data);
          const target_list = $("<ol/>");
          targets.map((target) => {
            target_list.append("<li>" + target + "</li>");
          });
          rules_container.append(target_list);

          rules_container.appendTo(repo_card);
        }

        octokit.repos.get(repo_info).then(inject_info);

        get_repo_files(repo_info).then(function ({data}) {
          data.filter(is_rules_file).map((file_info) => {
            get_repo_file_contents(repo_info, file_info).then(inject_targets);
          });
        });
      });
      });</script>
      </div>
    </main>

  </body>
</html>
